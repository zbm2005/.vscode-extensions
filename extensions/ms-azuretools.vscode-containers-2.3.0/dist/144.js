"use strict";exports.id=144,exports.ids=[144],exports.modules={18144:(e,s,t)=>{t.r(s),t.d(s,{StreamableHTTPServerTransport:()=>StreamableHTTPServerTransport});var i=t(37917),n=t(7680),r=t(58597),o=t(77598);class StreamableHTTPServerTransport{constructor(e){var s,t;this._started=!1,this._streamMapping=new Map,this._requestToStreamMapping=new Map,this._requestResponseMap=new Map,this._initialized=!1,this._enableJsonResponse=!1,this._standaloneSseStreamId="_GET_stream",this.sessionIdGenerator=e.sessionIdGenerator,this._enableJsonResponse=null!==(s=e.enableJsonResponse)&&void 0!==s&&s,this._eventStore=e.eventStore,this._onsessioninitialized=e.onsessioninitialized,this._onsessionclosed=e.onsessionclosed,this._allowedHosts=e.allowedHosts,this._allowedOrigins=e.allowedOrigins,this._enableDnsRebindingProtection=null!==(t=e.enableDnsRebindingProtection)&&void 0!==t&&t}async start(){if(this._started)throw new Error("Transport already started");this._started=!0}validateRequestHeaders(e){if(this._enableDnsRebindingProtection){if(this._allowedHosts&&this._allowedHosts.length>0){const s=e.headers.host;if(!s||!this._allowedHosts.includes(s))return`Invalid Host header: ${s}`}if(this._allowedOrigins&&this._allowedOrigins.length>0){const s=e.headers.origin;if(!s||!this._allowedOrigins.includes(s))return`Invalid Origin header: ${s}`}}}async handleRequest(e,s,t){var i;const n=this.validateRequestHeaders(e);if(n)return s.writeHead(403).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:n},id:null})),void(null===(i=this.onerror)||void 0===i||i.call(this,new Error(n)));"POST"===e.method?await this.handlePostRequest(e,s,t):"GET"===e.method?await this.handleGetRequest(e,s):"DELETE"===e.method?await this.handleDeleteRequest(e,s):await this.handleUnsupportedRequest(s)}async handleGetRequest(e,s){const t=e.headers.accept;if(!(null==t?void 0:t.includes("text/event-stream")))return void s.writeHead(406).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Not Acceptable: Client must accept text/event-stream"},id:null}));if(!this.validateSession(e,s))return;if(!this.validateProtocolVersion(e,s))return;if(this._eventStore){const t=e.headers["last-event-id"];if(t)return void await this.replayEvents(t,s)}const i={"Content-Type":"text/event-stream","Cache-Control":"no-cache, no-transform",Connection:"keep-alive"};void 0!==this.sessionId&&(i["mcp-session-id"]=this.sessionId),void 0===this._streamMapping.get(this._standaloneSseStreamId)?(s.writeHead(200,i).flushHeaders(),this._streamMapping.set(this._standaloneSseStreamId,s),s.on("close",(()=>{this._streamMapping.delete(this._standaloneSseStreamId)})),s.on("error",(e=>{var s;null===(s=this.onerror)||void 0===s||s.call(this,e)}))):s.writeHead(409).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Conflict: Only one SSE stream is allowed per session"},id:null}))}async replayEvents(e,s){var t,i;if(this._eventStore)try{const i={"Content-Type":"text/event-stream","Cache-Control":"no-cache, no-transform",Connection:"keep-alive"};void 0!==this.sessionId&&(i["mcp-session-id"]=this.sessionId),s.writeHead(200,i).flushHeaders();const n=await(null===(t=this._eventStore)||void 0===t?void 0:t.replayEventsAfter(e,{send:async(e,t)=>{var i;this.writeSSEEvent(s,t,e)||(null===(i=this.onerror)||void 0===i||i.call(this,new Error("Failed replay events")),s.end())}}));this._streamMapping.set(n,s),s.on("error",(e=>{var s;null===(s=this.onerror)||void 0===s||s.call(this,e)}))}catch(e){null===(i=this.onerror)||void 0===i||i.call(this,e)}}writeSSEEvent(e,s,t){let i="event: message\n";return t&&(i+=`id: ${t}\n`),i+=`data: ${JSON.stringify(s)}\n\n`,e.write(i)}async handleUnsupportedRequest(e){e.writeHead(405,{Allow:"GET, POST, DELETE"}).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Method not allowed."},id:null}))}async handlePostRequest(e,s,t){var a,d,l,h,c;try{const c=e.headers.accept;if(!(null==c?void 0:c.includes("application/json"))||!c.includes("text/event-stream"))return void s.writeHead(406).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Not Acceptable: Client must accept both application/json and text/event-stream"},id:null}));const p=e.headers["content-type"];if(!p||!p.includes("application/json"))return void s.writeHead(415).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Unsupported Media Type: Content-Type must be application/json"},id:null}));const u=e.auth,v={headers:e.headers};let m,g;if(void 0!==t)m=t;else{const s=r.parse(p),t=await n(e,{limit:"4mb",encoding:null!==(a=s.parameters.charset)&&void 0!==a?a:"utf-8"});m=JSON.parse(t.toString())}g=Array.isArray(m)?m.map((e=>i.OR.parse(e))):[i.OR.parse(m)];const f=g.some(i.isInitializeRequest);if(f){if(this._initialized&&void 0!==this.sessionId)return void s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32600,message:"Invalid Request: Server already initialized"},id:null}));if(g.length>1)return void s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32600,message:"Invalid Request: Only one initialization request is allowed"},id:null}));this.sessionId=null===(d=this.sessionIdGenerator)||void 0===d?void 0:d.call(this),this._initialized=!0,this.sessionId&&this._onsessioninitialized&&await Promise.resolve(this._onsessioninitialized(this.sessionId))}if(!f){if(!this.validateSession(e,s))return;if(!this.validateProtocolVersion(e,s))return}const S=g.some(i.vo);if(S){if(S){const e=(0,o.randomUUID)();if(!this._enableJsonResponse){const e={"Content-Type":"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"};void 0!==this.sessionId&&(e["mcp-session-id"]=this.sessionId),s.writeHead(200,e)}for(const t of g)(0,i.vo)(t)&&(this._streamMapping.set(e,s),this._requestToStreamMapping.set(t.id,e));s.on("close",(()=>{this._streamMapping.delete(e)})),s.on("error",(e=>{var s;null===(s=this.onerror)||void 0===s||s.call(this,e)}));for(const e of g)null===(h=this.onmessage)||void 0===h||h.call(this,e,{authInfo:u,requestInfo:v})}}else{s.writeHead(202).end();for(const e of g)null===(l=this.onmessage)||void 0===l||l.call(this,e,{authInfo:u,requestInfo:v})}}catch(e){s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32700,message:"Parse error",data:String(e)},id:null})),null===(c=this.onerror)||void 0===c||c.call(this,e)}}async handleDeleteRequest(e,s){var t;this.validateSession(e,s)&&this.validateProtocolVersion(e,s)&&(await Promise.resolve(null===(t=this._onsessionclosed)||void 0===t?void 0:t.call(this,this.sessionId)),await this.close(),s.writeHead(200).end())}validateSession(e,s){if(void 0===this.sessionIdGenerator)return!0;if(!this._initialized)return s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Bad Request: Server not initialized"},id:null})),!1;const t=e.headers["mcp-session-id"];return t?Array.isArray(t)?(s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Bad Request: Mcp-Session-Id header must be a single value"},id:null})),!1):t===this.sessionId||(s.writeHead(404).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32001,message:"Session not found"},id:null})),!1):(s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:"Bad Request: Mcp-Session-Id header is required"},id:null})),!1)}validateProtocolVersion(e,s){var t;let n=null!==(t=e.headers["mcp-protocol-version"])&&void 0!==t?t:i.PC;return Array.isArray(n)&&(n=n[n.length-1]),!!i.Iu.includes(n)||(s.writeHead(400).end(JSON.stringify({jsonrpc:"2.0",error:{code:-32e3,message:`Bad Request: Unsupported protocol version (supported versions: ${i.Iu.join(", ")})`},id:null})),!1)}async close(){var e;this._streamMapping.forEach((e=>{e.end()})),this._streamMapping.clear(),this._requestResponseMap.clear(),null===(e=this.onclose)||void 0===e||e.call(this)}async send(e,s){let t=null==s?void 0:s.relatedRequestId;if(((0,i.tG)(e)||(0,i.o$)(e))&&(t=e.id),void 0===t){if((0,i.tG)(e)||(0,i.o$)(e))throw new Error("Cannot send a response on a standalone SSE stream unless resuming a previous client request");const s=this._streamMapping.get(this._standaloneSseStreamId);if(void 0===s)return;let t;return this._eventStore&&(t=await this._eventStore.storeEvent(this._standaloneSseStreamId,e)),void this.writeSSEEvent(s,e,t)}const n=this._requestToStreamMapping.get(t),r=this._streamMapping.get(n);if(!n)throw new Error(`No connection established for request ID: ${String(t)}`);if(!this._enableJsonResponse){let s;this._eventStore&&(s=await this._eventStore.storeEvent(n,e)),r&&this.writeSSEEvent(r,e,s)}if((0,i.tG)(e)||(0,i.o$)(e)){this._requestResponseMap.set(t,e);const s=Array.from(this._requestToStreamMapping.entries()).filter((([e,s])=>this._streamMapping.get(s)===r)).map((([e])=>e));if(s.every((e=>this._requestResponseMap.has(e)))){if(!r)throw new Error(`No connection established for request ID: ${String(t)}`);if(this._enableJsonResponse){const e={"Content-Type":"application/json"};void 0!==this.sessionId&&(e["mcp-session-id"]=this.sessionId);const t=s.map((e=>this._requestResponseMap.get(e)));r.writeHead(200,e),1===t.length?r.end(JSON.stringify(t[0])):r.end(JSON.stringify(t))}else r.end();for(const e of s)this._requestResponseMap.delete(e),this._requestToStreamMapping.delete(e)}}}}}};